{
  "phase": 2,
  "sprint": 2,
  "todoFile": 2,
  "title": "OCR Results Panel & Searchable PDF Export",
  "priority": "HIGH",
  "effort": "4 hours",
  "status": "pending",
  "milestone": "OCR Processing UI",
  "tasks": [
    {
      "id": "2.2.4",
      "category": "ui",
      "title": "Create OCR Results Panel",
      "description": "Build the sidebar panel displaying OCR text results with confidence indicators and editing capabilities.",
      "status": "pending",
      "estimatedHours": 2,
      "agent": "sonnet",
      "files": ["src/components/ocr/OCRResultsPanel.tsx"],
      "testCategories": ["visual", "integration"],
      "stepByStep": [
        {
          "step": 1,
          "action": "Create OCRResultsPanel component with confidence highlighting",
          "code": "import { useState, useMemo } from 'react';\nimport { Search, Copy, Download, Edit2, Check, X } from 'lucide-react';\nimport { Button } from '@components/ui/Button';\nimport { Input } from '@components/ui/Input';\nimport { useOCRStore } from '@stores/ocrStore';\nimport { cn } from '@utils/cn';\n\nexport function OCRResultsPanel() {\n  const { results, currentPage } = useOCRStore();\n  const [searchQuery, setSearchQuery] = useState('');\n  const [editingWordIndex, setEditingWordIndex] = useState<number | null>(null);\n  const [editValue, setEditValue] = useState('');\n\n  const pageResult = results.get(currentPage);\n\n  const filteredWords = useMemo(() => {\n    if (!pageResult) return [];\n    if (!searchQuery) return pageResult.words;\n    const lower = searchQuery.toLowerCase();\n    return pageResult.words.filter(w => w.text.toLowerCase().includes(lower));\n  }, [pageResult, searchQuery]);\n\n  const handleCopyText = async () => {\n    if (!pageResult) return;\n    try {\n      await navigator.clipboard.writeText(pageResult.text);\n    } catch (error) {\n      console.error('Failed to copy text:', error);\n    }\n  };\n\n  const handleExportText = () => {\n    if (!pageResult) return;\n    const blob = new Blob([pageResult.text], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `ocr-page-${currentPage + 1}.txt`;\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const getConfidenceColor = (confidence: number): string => {\n    if (confidence >= 90) return 'bg-green-100 dark:bg-green-900/30';\n    if (confidence >= 70) return 'bg-yellow-100 dark:bg-yellow-900/30';\n    return 'bg-red-100 dark:bg-red-900/30';\n  };\n\n  const handleStartEdit = (index: number, text: string) => {\n    setEditingWordIndex(index);\n    setEditValue(text);\n  };\n\n  const handleSaveEdit = (index: number) => {\n    // Update word in store\n    setEditingWordIndex(null);\n    setEditValue('');\n  };\n\n  if (!pageResult) {\n    return (\n      <div className=\"p-4 text-center text-gray-500\">\n        No OCR results for this page. Run OCR to recognize text.\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Toolbar */}\n      <div className=\"p-2 border-b flex items-center gap-2\">\n        <div className=\"relative flex-1\">\n          <Search className=\"absolute left-2 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400\" />\n          <Input\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            placeholder=\"Search in results...\"\n            className=\"pl-8 h-8\"\n            aria-label=\"Search OCR results\"\n          />\n        </div>\n        <Button \n          variant=\"ghost\" \n          size=\"icon\" \n          onClick={handleCopyText}\n          aria-label=\"Copy all text\"\n        >\n          <Copy className=\"h-4 w-4\" />\n        </Button>\n        <Button \n          variant=\"ghost\" \n          size=\"icon\" \n          onClick={handleExportText}\n          aria-label=\"Export as text file\"\n        >\n          <Download className=\"h-4 w-4\" />\n        </Button>\n      </div>\n\n      {/* Confidence Legend */}\n      <div className=\"p-2 border-b flex items-center gap-4 text-xs\">\n        <span className=\"flex items-center gap-1\">\n          <span className=\"w-3 h-3 rounded bg-green-100 dark:bg-green-900/30\" />\n          High (â‰¥90%)\n        </span>\n        <span className=\"flex items-center gap-1\">\n          <span className=\"w-3 h-3 rounded bg-yellow-100 dark:bg-yellow-900/30\" />\n          Medium (70-89%)\n        </span>\n        <span className=\"flex items-center gap-1\">\n          <span className=\"w-3 h-3 rounded bg-red-100 dark:bg-red-900/30\" />\n          Low (&lt;70%)\n        </span>\n      </div>\n\n      {/* Results */}\n      <div className=\"flex-1 overflow-y-auto p-2\">\n        <div className=\"flex flex-wrap gap-1\">\n          {filteredWords.map((word, index) => (\n            <span\n              key={index}\n              className={cn(\n                'px-1 rounded cursor-pointer hover:ring-1 hover:ring-primary-500',\n                getConfidenceColor(word.confidence)\n              )}\n              title={`Confidence: ${word.confidence.toFixed(1)}%`}\n              onClick={() => handleStartEdit(index, word.text)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => e.key === 'Enter' && handleStartEdit(index, word.text)}\n            >\n              {editingWordIndex === index ? (\n                <span className=\"inline-flex items-center gap-1\">\n                  <input\n                    type=\"text\"\n                    value={editValue}\n                    onChange={(e) => setEditValue(e.target.value)}\n                    className=\"w-20 px-1 border rounded text-sm\"\n                    autoFocus\n                    aria-label=\"Edit word\"\n                  />\n                  <button onClick={() => handleSaveEdit(index)} aria-label=\"Save edit\">\n                    <Check className=\"h-3 w-3 text-green-600\" />\n                  </button>\n                  <button onClick={() => setEditingWordIndex(null)} aria-label=\"Cancel edit\">\n                    <X className=\"h-3 w-3 text-red-600\" />\n                  </button>\n                </span>\n              ) : (\n                word.text\n              )}\n            </span>\n          ))}\n        </div>\n      </div>\n\n      {/* Stats */}\n      <div className=\"p-2 border-t text-sm text-gray-600 dark:text-gray-400\">\n        <div className=\"flex justify-between\">\n          <span>{pageResult.words.length} words recognized</span>\n          <span>Avg confidence: {(pageResult.confidence).toFixed(1)}%</span>\n        </div>\n        <div className=\"text-xs mt-1\">Processing time: {pageResult.processingTime}ms</div>\n      </div>\n    </div>\n  );\n}"
        }
      ],
      "acceptanceCriteria": [
        "Results panel shows recognized words",
        "Confidence colors are correct",
        "Search filters words in real-time",
        "Copy to clipboard works",
        "Export to text file works",
        "Word editing works",
        "Keyboard navigation is accessible"
      ]
    },
    {
      "id": "2.2.5",
      "category": "implementation",
      "title": "Implement Searchable PDF Text Layer Embedding",
      "description": "Create function to embed invisible text layer into PDF for text selection and search.",
      "status": "pending",
      "estimatedHours": 2,
      "agent": "sonnet",
      "files": ["src/lib/ocr/textLayerEmbed.ts"],
      "testCategories": ["unit", "integration"],
      "stepByStep": [
        {
          "step": 1,
          "action": "Create text layer embedding function with error handling",
          "code": "import { PDFDocument, rgb, StandardFonts, PDFPage, PDFFont } from 'pdf-lib';\nimport type { OCRResult, OCRWord } from './types';\n\nexport interface EmbedOptions {\n  invisible: boolean;\n  preserveFormatting: boolean;\n}\n\nexport interface EmbedResult {\n  success: boolean;\n  pdfBytes: ArrayBuffer | null;\n  wordsEmbedded: number;\n  errors: string[];\n}\n\nexport async function embedTextLayer(\n  pdfBytes: ArrayBuffer,\n  ocrResults: Map<number, OCRResult>,\n  options: EmbedOptions = { invisible: true, preserveFormatting: true }\n): Promise<EmbedResult> {\n  const errors: string[] = [];\n  let wordsEmbedded = 0;\n\n  try {\n    const pdfDoc = await PDFDocument.load(pdfBytes);\n    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n    const pages = pdfDoc.getPages();\n\n    for (const [pageIndex, result] of ocrResults) {\n      if (pageIndex >= pages.length) {\n        errors.push(`Page index ${pageIndex} out of bounds`);\n        continue;\n      }\n\n      try {\n        const page = pages[pageIndex];\n        const embedCount = await embedPageText(page, result, font, options);\n        wordsEmbedded += embedCount;\n      } catch (pageError) {\n        errors.push(`Error embedding page ${pageIndex}: ${pageError instanceof Error ? pageError.message : 'Unknown error'}`);\n      }\n    }\n\n    const savedBytes = await pdfDoc.save();\n    return {\n      success: errors.length === 0,\n      pdfBytes: savedBytes.buffer,\n      wordsEmbedded,\n      errors,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      pdfBytes: null,\n      wordsEmbedded: 0,\n      errors: [`Failed to process PDF: ${error instanceof Error ? error.message : 'Unknown error'}`],\n    };\n  }\n}\n\nasync function embedPageText(\n  page: PDFPage,\n  result: OCRResult,\n  font: PDFFont,\n  options: EmbedOptions\n): Promise<number> {\n  const { width, height } = page.getSize();\n  let count = 0;\n\n  for (const word of result.words) {\n    try {\n      const { bbox, text } = word;\n      if (!text.trim()) continue;\n\n      // Convert OCR coordinates to PDF coordinates\n      // OCR uses top-left origin, PDF uses bottom-left\n      const x = bbox.x0;\n      const y = height - bbox.y1;\n\n      // Calculate font size to match word width\n      const fontSize = calculateFontSize(font, text, bbox.x1 - bbox.x0);\n\n      page.drawText(text, {\n        x,\n        y,\n        size: fontSize,\n        font,\n        color: options.invisible ? rgb(1, 1, 1) : rgb(0, 0, 0),\n        opacity: options.invisible ? 0 : 1,\n      });\n\n      count++;\n    } catch (wordError) {\n      // Skip individual word errors to continue processing\n      console.warn(`Failed to embed word: ${word.text}`, wordError);\n    }\n  }\n\n  return count;\n}\n\nfunction calculateFontSize(\n  font: PDFFont,\n  text: string,\n  targetWidth: number\n): number {\n  // Start with base size and scale to fit\n  const baseSize = 12;\n  const measuredWidth = font.widthOfTextAtSize(text, baseSize);\n\n  if (measuredWidth <= 0) return baseSize;\n\n  const scaledSize = (targetWidth / measuredWidth) * baseSize;\n\n  // Clamp to reasonable range\n  return Math.max(4, Math.min(scaledSize, 72));\n}"
        }
      ],
      "acceptanceCriteria": [
        "Text layer embeds without errors",
        "Text positions match original OCR locations",
        "Invisible text mode works (opacity 0)",
        "Text is selectable in output PDF",
        "Search finds embedded text",
        "Error handling covers edge cases",
        "Returns meaningful error messages"
      ]
    }
  ],
  "successCriteria": [
    "Results panel displays OCR output with confidence",
    "Users can search, copy, and export text",
    "Searchable PDF export works correctly",
    "Text selection works in exported PDFs"
  ],
  "filesCreated": [
    "src/components/ocr/OCRResultsPanel.tsx",
    "src/lib/ocr/textLayerEmbed.ts",
    "tests/unit/components/ocr/OCRResultsPanel.test.tsx",
    "tests/unit/lib/ocr/textLayerEmbed.test.ts"
  ],
  "filesModified": [],
  "totalNewTests": 8,
  "totalEstimatedHours": 4,
  "dependencies": ["2.2.1", "2.2.2", "2.2.3"],
  "notes": [
    "Confidence thresholds may need tuning based on user feedback",
    "Consider adding undo/redo for word edits",
    "PDF text layer positioning depends on OCR bbox accuracy"
  ]
}
